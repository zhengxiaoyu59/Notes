## 性能场景
* 基准性能场景
* 容量性能场景
* 稳定性性能场景
* 异常性能场景

![图](https://github.com/zhengxiaoyu59/Notes/blob/master/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/images/021.png?raw=true)  
* 三条曲线：使用率/用户数（Utilization），吞吐量（Throughput），响应时间（Response Time）  
* 三个区域：轻负载区（Light Load），重负载区（Heavy Load），塌陷区（Buckle Zone）  
* 两个点：最优并发用户数（The Optimum Number of Concurrent Users），最大并发用户数（The Maximum Number of Concurrent Users）  
* 三个状态描述：资源饱和（Resource Saturated），吞吐下降（Throughput Falling），用户受影响（End Users Effected）  

图中有些地方可能与实际存在误差：  
* 重负载区的资源饱和 与 TPS达到最大值 不是在同样的并发用户数之下的。  
> e.g.当CPU资源使用率达到100%后，随着压力增加，队列变长。由于用户数的增加幅度会超过队列长度的增加幅度，所以TPS仍会增加。
即，资源使用率达到饱和后，TPS仍会上升然后达到上限。  
（个人理解为，用户增加速度与将用户加入队列的速度不同，队列长度有上限；队列长度增加时，TPS上升，满队列时，TPS达到上限）  
大部分情况下，响应时间曲线不会这么陡峭，也不一定是在塌陷区突然上升，更可能在重负载区突然上升。  

* 吞吐量曲线不一定会出现下降的情况，在有些控制较好的系统中会维持水平。
> 达到最大TPS后，就没必要继续施压了，目标是知道TPS的上限而不是压死。  

* 最优并发数，没有绝对的数据来证明，在生产运维过程中，会在这个点靠前一点作为最优并发。

* 最大并发数，没有道理，性能已经衰退了，最大并发数肯定在更前的位置。
> 更关心TPS（服务端能处理的请求数），而不是压力工具中的线程数。  

上图没有考虑锁或线程等配置不合理而又常见的场景，也就是TPS上不去，资源用不上。所以此图默认了一个前提，只要线程能用上，资源就会上涨。  


